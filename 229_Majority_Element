'''
Given an array nums of size n, return the majority element.

The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.

 

Example 1:

Input: nums = [3,2,3]
Output: 3
Example 2:

Input: nums = [2,2,1,1,1,2,2]
Output: 2
 

Constraints:

n == nums.length
1 <= n <= 5 * 104
-109 <= nums[i] <= 109
 

Follow-up: Could you solve the problem in linear time and in O(1) space?
'''

import unittest
from typing import List

class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        candidate = None
        count = 0

        for num in nums:
            if count == 0:
                candidate = num
            if candidate is None:
                continue
            if candidate == num:
                count += 1
            else:
                count -= 1
        return candidate


# Testing:

class TestMajorityElement(unittest.TestCase):
    def setUp(self):
        self.solution = Solution()

    def test_single_element(self):
        self.assertEqual(self.solution.majorityElement([1]), 1)

    def test_all_same(self):
        self.assertEqual(self.solution.majorityElement([2,2,2,2]), 2)

    def test_majority_at_end(self):
        self.assertEqual(self.solution.majorityElement([3,1,3]), 3)

    def test_majority_in_middle(self):
        self.assertEqual(self.solution.majorityElement([4,5,4,4,7]), 4)

    def test_even_length(self):
        self.assertEqual(self.solution.majorityElement([6,6,6,7,7,6]), 6)

    def test_negative_majority(self):
        self.assertEqual(self.solution.majorityElement([-1,-1,-1,2,2]), -1)

    def test_large_input(self):
        nums = [9]*51 + [1]*49
        self.assertEqual(self.solution.majorityElement(nums), 9)

    def test_empty_input(self):
        nums = {}
        self.assertEqual(self.solution.majorityElement(nums), None)

if __name__ == "__main__":
    unittest.main(exit=False)